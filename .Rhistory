A2_est <- coef(var_model)$y2[, 1:2]  # Coefficients of y2,t ~ y1,t-1 + y2,t-1
A_est <- rbind(coef(var_model)$y1[ , 1:2],
coef(var_model)$y2[ , 1:2])
eigenvalues <- eigen(A_est)
library(MASS)
library(vars)
set.seed(1000)
# Parameters
A1 <- matrix(c(0.5, 0.2, -0.3, 0.7), nrow = 2, byrow = TRUE)
n <- 200
k <- 2
I2 <- diag(2)
Y <- matrix(0, nrow = n, ncol = k)
# Simulate data
for (t in 2:n) {
eps_t <- mvrnorm(1, mu = c(0, 0), Sigma = I2)
Y[t, ] <- A1 %*% Y[t - 1, ] + eps_t
}
# time series
Y_ts <- ts(Y, start = 1, frequency = 1)
colnames(Y_ts) <- c("y1", "y2")
# Estimate VAR(1)
var_model <- VAR(Y_ts, p = 1, type = "const")
summary(var_model)
A1_est <- coef(var_model)$y1[2:3, 1]  # y1 equation: y1_lag, y2_lag
A2_est <- coef(var_model)$y2[2:3, 1]  # y2 equation: y1_lag, y2_lag
# Combine into a 2x2 matrix: rows = equations for y1 and y2
A_est <- cbind(A1_est, A2_est)
A_est <- t(A_est)  # transpose to match (2 x 2) structure
# Now A_est is square
eigenvalues <- eigen(A_est)$values
print(eigenvalues)
all(Mod(eigenvalues) < 1)  # TRUE if stationary
library(MASS)
library(vars)
set.seed(1000)
# Parameters
A1 <- matrix(c(0.5, 0.2, -0.3, 0.7), nrow = 2, byrow = TRUE)
n <- 200
k <- 2
I2 <- diag(2)
Y <- matrix(0, nrow = n, ncol = k)
# Simulate data
for (t in 2:n) {
eps_t <- mvrnorm(1, mu = c(0, 0), Sigma = I2)
Y[t, ] <- A1 %*% Y[t - 1, ] + eps_t
}
# time series
Y_ts <- ts(Y, start = 1, frequency = 1)
colnames(Y_ts) <- c("y1", "y2")
# Estimate VAR(1)
var_model <- VAR(Y_ts, p = 1, type = "const")
summary(var_model)
A1_est <- coef(var_model)$y1[2:3, 1]
A2_est <- coef(var_model)$y2[2:3, 1]
A_est <- cbind(A1_est, A2_est)
A_est <- t(A_est)
eigenvalues <- eigen(A_est)$values
print(eigenvalues)
# check if stationary
all(Mod(eigenvalues) < 1)
ts.plot(Y_ts, col = c("blue", "red"), lty = 1:2, ylab = "Values", main = "Simulated VAR(1) Process")
legend("topright", legend = c("y1", "y2"), col = c("blue", "red"), lty = 1:2)
library(MASS)
library(vars)
set.seed(1000)
# Parameters
A1 <- matrix(c(0.5, 0.2, -0.3, 0.7), nrow = 2, byrow = TRUE)
n <- 200
k <- 2
I2 <- diag(2)
Y <- matrix(0, nrow = n, ncol = k)
# Simulate data
for (t in 2:n) {
eps_t <- mvrnorm(1, mu = c(0, 0), Sigma = I2)
Y[t, ] <- A1 %*% Y[t - 1, ] + eps_t
}
# time series
Y_ts <- ts(Y, start = 1, frequency = 1)
colnames(Y_ts) <- c("y1", "y2")
# Estimate VAR(1)
var_model <- VAR(Y_ts, p = 1, type = "const")
summary(var_model)
A1_est <- coef(var_model)$y1[2:3, 1]
A2_est <- coef(var_model)$y2[2:3, 1]
A_est <- cbind(A1_est, A2_est)
A_est <- t(A_est)
eigenvalues <- eigen(A_est)$values
print(eigenvalues)
# check if stationary
all(Mod(eigenvalues) < 1)
ts.plot(Y_ts, col = c("blue", "red"), lty = 1:2, ylab = "Values", main = "Simulated VAR(1) Process")
legend("topright", legend = c("y1", "y2"), col = c("blue", "red"), lty = 1:2)
eigen_original <- eigen(A1)$values
Mod(eigen_original)
eigen_original <- eigen(A1)$values
Mod(eigen_original)
library(extraDistr)
#######   SIMULATION 1.   ###############
set.seed(2)
C <- c(50, 60)   # number of cells in each dataset
G <- 100           # number of genes
D <- 2            # number of datasets / experiments
J <- 3           # number of shared clusters
## Define capture efficiency distribution hyperparameters
##### Each cell’s capture efficiency β_c is drawn from a Beta(a, b) distribution.
a_beta <- 1
b_beta <- 0.5
## Define parameters for mean–dispersion relationship
b <- c(0,3)           # controls the relationship between mean and dispersion of expression per gene.
alpha_mu2 <- 1        # variance in the log-normal prior for gene means (μ).
alpha_phi2 <- 1.      #variance in the log-normal prior for gene dispersions (φ).
## Define cluster proportions per dataset
p_jd <- matrix(0, nrow = J, ncol = D)
p_jd[,1] <- c(0.4, 0,0.6)
p_jd[,2] <- c(0.6, 0.4, 0)
#p_jd[,1] <- c(0.1,0.15,0, 0.2, 0.05, 0.2, 0.1,0.1,0.06, 0.04)
#p_jd[,2] <- c(0.04,0.06,0.1, 0.1, 0.2, 0.05, 0.2,0.15,0, 0.1)
## Simulate cell-specific capture efficiencies
### For each dataset d, draw C[d] values of β_c ~ Beta(1, 0.5).
sim1_beta <- lapply(1:D,
function(d) rbeta(n = C[d], shape1 = a_beta, shape2 = b_beta))
## Simulate cluster-level gene means
#### μ_jg ~ LogNormal(0, α_μ²). Each cluster j has its own gene mean expression for each gene g.
sim1_mu <- matrix(rlnorm(n = J*G,
meanlog = 0,
sdlog = sqrt(alpha_mu2)),
nrow = J,
ncol = G)
## Simulate cluster-level gene dispersions
sim1_phi <- matrix(rlnorm(n = J*G,
meanlog = b[1] + b[2]*log(as.vector(sim1_mu)),
sdlog = sqrt(alpha_phi2)),
nrow = J,
ncol = G)
## Assign cluster membership for each cell
sim1_z <- lapply(1:D,
function(d) rcat(n = C[d],
prob = p_jd[,d]))
##Generate observed counts
sim_data1 <- lapply(1:D,
function(d) matrix(rnbinom(n = C[d]*G,
mu = rep(sim1_beta[[d]], each = G)*as.vector(t(sim1_mu[sim1_z[[d]],])),
size = as.vector(t(sim1_phi[sim1_z[[d]],]))),
nrow = G,
ncol = C[d]))
library(pbapply)
library(png)
library(grid)
D = length(sim_data1)
beta.mean <- 0.5
BB_SIZE = TRUE
baynorm.beta <- lapply(1:D, function(d){
bayNorm::BetaFun(Data = sim_data1[[d]],
MeanBETA = beta.mean)$BETA
})
# Apply bayNorm to the combined dataset
baynorm_tot <- bayNorm(Data = do.call(cbind, sim_data1),
BETA_vec = unlist(baynorm.beta),
mode_version = TRUE,
mean_version = FALSE,
BB_SIZE = BB_SIZE)
library('bayNorm')
library(normHDPcpp)
library('normHDP')
# Apply bayNorm to the combined dataset
baynorm_tot <- bayNorm(Data = do.call(cbind, sim_data1),
BETA_vec = unlist(baynorm.beta),
mode_version = TRUE,
mean_version = FALSE,
BB_SIZE = BB_SIZE)
# Estimate of mu
baynorm.mu.estimate <- baynorm_tot$PRIORS$MME_prior[,1]
# Estimate of phi
if(isFALSE(BB_SIZE)){
baynorm.phi.estimate <- baynorm_tot$PRIORS$MME_prior[,2]
}else{
baynorm.phi.estimate <- baynorm_tot$PRIORS$MME_SIZE_adjust
}
# Example:
Y_list <- list(
as.matrix(sim_data1[[1]]),
as.matrix(sim_data1[[2]])
)
res <- ensemble_mcmc_R(
Y_list,
J = 10,
num_chains = 100,
chain_length = 100,
thinning = 10,
empirical = TRUE,
burn_in = 10,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
print_progress = FALSE,
num_cores = -1,
baynorm.mu.estimate,
baynorm.phi.estimate,
baynorm.beta
)
Z_opt <- consensus_clustering(Z_output = res$Z_trace_all,
num.cores = 4,
run.on.pc = TRUE)
Z_opt$cluster.estimate
Z_opt$psm
Z_fixed <- lapply(Z_opt$cluster.estimate, function(z) {
as.integer(factor(z)) - 1
})
MCMC_run <- normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_fixed,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
getAnywhere("normHDP_mcmc_fixed_z")
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_fixed,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_fixed,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
J1 <- 10
Z_correct <- lapply(Z_fixed, function(z) {
z_new <- z
# force Z to have labels 0..(J-1)
# empty clusters are okay
# but the labels must exist in the vector at least once
z_dummy <- 0:(J1-1)
# does nothing to real cells, only appends dummy labels
c(z_new, z_dummy)
})
Z_correct <- lapply(Z_correct, function(z) as.integer(z))
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_correct,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Z_correct <- lapply(Z_correct, function(z) as.integer(z))
Z_correct <- lapply(Z_fixed, function(z) {
z_new <- z
# force Z to have labels 0..(J-1)
# empty clusters are okay
# but the labels must exist in the vector at least once
z_dummy <- 0:(J1-1)
# does nothing to real cells, only appends dummy labels
c(z_new, z_dummy)
})
Z_correct <- lapply(Z_correct, function(z) as.integer(z))
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_correct,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
beta_compare(Y = sim_data1,
normHDP_post_output = MCMC_run,
data.names = c('data1','data2'))
table(Z_correct)
min(unlist(baynorm.beta))
max(unlist(baynorm.beta))
table(Z_correct)
length(unique(Z_correct[[1]]))
Z_opt$cluster.estimate
setwd("Desktop/thesis/paper1/analysis/normhdpcpp_package/normHDPcpp")
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_correct,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Rcpp::compileAttributes()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_correct,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Rcpp::compileAttributes()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_correct,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Z_fixed <- lapply(Z_opt$cluster.estimate, function(z) as.integer(factor(z)) - 1)
sapply(Z_fixed, unique)
# [[1]] 0 1
# [[2]] 0 1
sapply(Z_fixed, max)
Z_opt$cluster.estimate
# First, find all unique clusters across datasets
all_clusters <- sort(unique(unlist(Z_opt$cluster.estimate)))
# all_clusters
# [1] 0 4 7
# Map original cluster labels to 0,1,2
cluster_map <- setNames(0:(length(all_clusters)-1), all_clusters)
Z_fixed <- lapply(Z_opt$cluster.estimate, function(z) cluster_map[as.character(z)])
sapply(Z_fixed, unique)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
Z = Z_fixed,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Rcpp::compileAttributes()
devtools::load_all()
Rcpp::compileAttributes()
devtools::load_all()
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
cluster_estimates = Z_opt$cluster.estimate,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Rcpp::compileAttributes()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
cluster_estimates = Z_opt$cluster.estimate,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Rcpp::compileAttributes()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
cluster_estimates = Z_opt$cluster.estimate,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Rcpp::compileAttributes()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
cluster_estimates = Z_opt$cluster.estimate,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
Rcpp::compileAttributes()
devtools::load_all()
library(normHDPcpp)
MCMC_run <- normHDPcpp::normHDP_mcmc_fixed_z(Y = Y_list,
cluster_estimates = Z_opt$cluster.estimate,
number_iter = 5000,
thinning = 5,
empirical = TRUE,
burn_in = 2000,
quadratic = FALSE,
iter_update = 100,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta
)
