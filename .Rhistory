# ========================================
# Generate count data
# ========================================
sim_data_horseshoe<- lapply(1:D, function(d) {
matrix(
rnbinom(
n = C[d] * G,
mu = rep(sim_beta[[d]], each = G) * as.vector(t(sim_mu[sim_Z[[d]], ])),
size = as.vector(t(sim_phi[sim_Z[[d]], ]))
),
nrow = G,
ncol = C[d]
)
})
View(sim_data_horseshoe)
sim_data_horseshoe[[1]]
D <- 2
G <- 150
C <- c(300,400)
a_beta <- 1
b_beta <- 0.5
p_jd <- matrix(0, nrow = J, ncol = D)
p_jd[,1] <- c(0.8,0.2,0)
p_jd[,2] <- c(0.8,0,0.2)
b <- c(-1, 1)
sim3_beta <- lapply(1:D,
function(d) rbeta(n = C[d], shape1 = a_beta, shape2 = b_beta))
sim3_Z <- lapply(1:D,
function(d) rcat(n = C[d],
prob = p_jd[,d]))
sim3_mu <- matrix(0, nrow = J, ncol = G)
sim3_phi <- matrix(0, nrow = J, ncol = G)
# Non-marker genes
sim3_mu_nonmarker <- rlnorm(n = 150-106+1,
meanlog = 3.5,
sdlog = 0.5)
sim3_mu[,106:150] <- matrix(rep(sim3_mu_nonmarker,
each = J),
ncol = 150-106+1)
# Marker genes
sim3_mu[1,1:105] <- rlnorm(n = 105,
meanlog = -3,
sdlog = 0.1)
sim3_mu[2,1:105] <- rlnorm(n = 105,
meanlog = 5,
sdlog = 0.1)
sim3_mu[3,1:105] <- rlnorm(n = 105,
meanlog = 8,
sdlog = 0.1)
sim3_phi_nonmarker <- rlnorm(n = 150-106+1,
meanlog = log(sim3_mu_nonmarker),
sdlog = 0.1)
sim3_phi[,106:150] <- matrix(rep(sim3_phi_nonmarker,
each = J),
ncol = 150-106+1)
sim3_phi[,1:105] <- matrix(rlnorm(n = 105*J,
meanlog = b[1] + b[2]*log(as.vector(sim3_mu[,1:105])),
sdlog = 0.1),
nrow = J,
ncol = 105)
sim_data3 <- lapply(1:D,
function(d) matrix(rnbinom(n = C[d]*G,
mu = rep(sim3_beta[[d]], each = G)*as.vector(t(sim3_mu[sim3_Z[[d]],])),
size = as.vector(t(sim3_phi[sim3_Z[[d]],]))),
nrow = G,
ncol = C[d])
)
D <- 2
G <- 150
C <- c(300,400)
a_beta <- 1
b_beta <- 0.5
p_jd <- matrix(0, nrow = J, ncol = D)
library(extraDistr)
library(ggplot2)
library(ggplot2)
library(reshape2)
library(extraDistr)
library('normHDP')
library('bayNorm')
library(normHDPcpp)
library(tidyverse)
library(pbapply)
library(png)
library(grid)
library(fields)
library(mvtnorm)
library(SciViews)
library(doParallel)
library(foreach)
library(ggplot2)
library(ggpubr)
library(Matrix)
library(Rtsne)
library(DescTools)
library(ggrepel)
library(parallel)
library(progress)
library(matrixStats)
library(data.table)
library(reshape2)
set.seed(2)
C <- c(50, 100)   # number of cells in each dataset
G <- 50           # number of genes
D <- 2            # number of datasets / experiments
J <- 3          # number of shared clusters
## Define capture efficiency distribution hyperparameters
##### Each cell’s capture efficiency β_c is drawn from a Beta(a, b) distribution.
a_beta <- 1
b_beta <- 0.5
## Define parameters for mean–dispersion relationship
b <- c(0,3)           # controls the relationship between mean and dispersion of expression per gene.
alpha_mu2 <- 1        # variance in the log-normal prior for gene means (μ).
alpha_phi2 <- 1.      #variance in the log-normal prior for gene dispersions (φ).
D <- 2
GG <- 150
CC <- c(300,400)
a_beta <- 1
b_beta <- 0.5
p_jd <- matrix(0, nrow = J, ncol = D)
p_jd[,1] <- c(0.8,0.2,0)
p_jd[,2] <- c(0.8,0,0.2)
b <- c(-1, 1)
sim3_beta <- lapply(1:D,
function(d) rbeta(n = CC[d], shape1 = a_beta, shape2 = b_beta))
sim3_Z <- lapply(1:D,
function(d) rcat(n = CC[d],
prob = p_jd[,d]))
sim3_mu <- matrix(0, nrow = J, ncol = GG)
sim3_phi <- matrix(0, nrow = J, ncol = GG)
# Non-marker genes
sim3_mu_nonmarker <- rlnorm(n = 150-106+1,
meanlog = 3.5,
sdlog = 0.5)
sim3_mu[,106:150] <- matrix(rep(sim3_mu_nonmarker,
each = J),
ncol = 150-106+1)
# Marker genes
sim3_mu[1,1:105] <- rlnorm(n = 105,
meanlog = -3,
sdlog = 0.1)
sim3_mu[2,1:105] <- rlnorm(n = 105,
meanlog = 5,
sdlog = 0.1)
sim3_mu[3,1:105] <- rlnorm(n = 105,
meanlog = 8,
sdlog = 0.1)
sim3_phi_nonmarker <- rlnorm(n = 150-106+1,
meanlog = log(sim3_mu_nonmarker),
sdlog = 0.1)
sim3_phi[,106:150] <- matrix(rep(sim3_phi_nonmarker,
each = J),
ncol = 150-106+1)
sim3_phi[,1:105] <- matrix(rlnorm(n = 105*J,
meanlog = b[1] + b[2]*log(as.vector(sim3_mu[,1:105])),
sdlog = 0.1),
nrow = J,
ncol = 105)
sim_data_markergene <- lapply(1:D,
function(d) matrix(rnbinom(n = CC[d]*GG,
mu = rep(sim3_beta[[d]], each = GG)*as.vector(t(sim3_mu[sim3_Z[[d]],])),
size = as.vector(t(sim3_phi[sim3_Z[[d]],]))),
nrow = GG,
ncol = CC[d]))
#######   NormHDP with linear mu and phi   ###############
D = length(sim_data_markergene)
beta.mean <- 0.7
BB_SIZE = TRUE
# get empirical beta estimates from each of the data set #
baynorm.beta <- lapply(1:D, function(d){
bayNorm::BetaFun(Data = sim_data_markergene[[d]],
MeanBETA = beta.mean)$BETA
})
## get empirical empirical mu from baynormm to get a starting state for each mu and phi in a cluster in mcmc sampling #
baynorm_tot <- bayNorm(Data = do.call(cbind, sim_data_markergene),
BETA_vec = unlist(baynorm.beta),
mode_version = TRUE,
mean_version = FALSE,
BB_SIZE = BB_SIZE)
baynorm.mu.estimate <- baynorm_tot$PRIORS$MME_prior[,1]
# Estimate of phi
if(isFALSE(BB_SIZE)){
baynorm.phi.estimate <- baynorm_tot$PRIORS$MME_prior[,2]
}else{
baynorm.phi.estimate <- baynorm_tot$PRIORS$MME_SIZE_adjust
}
normHDP_result_markergene <- ensemble_mcmc_R(
sim_data_markergene,
J = 20,
num_chains = 100,
chain_length = 100,
thinning = 1,
empirical = TRUE,
burn_in = 0,
quadratic = FALSE,
iter_update = 100,
beta_mean = beta.mean,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
print_progress = FALSE,
num_cores = -1,
save_only_z = TRUE,
use_sparse_prior = FALSE,
baynorm.mu.estimate,
baynorm.phi.estimate,
baynorm.beta
)
Z_opt1 <- consensus_clustering(Z_output = normHDP_result_markergene$Z_trace_all,
num.cores = 4,
run.on.pc = TRUE)
Z_opt1$cluster.estimate
Z_opt1$psm
plotpsm(psm.ind = Z_opt1$psm$psm.within,
psm.tot = Z_opt1$psm$psm.combined,
method = 'complete',
plot1.name = 'psmt',
plot2.name = 'psm2ind',
xlab = 'Cell',
ylab = 'Cell')
img1 <- readPNG("psmt.png")
grid::grid.raster(img1)
cluster_summary(Z = Z_opt1$cluster.estimate,
data.name = c('data1',
'data2'))
MCMC_run1 <- normHDPcpp::normHDP_mcmc_fixed_z(Y = sim_data_markergene,
cluster_estimates = Z_opt1$cluster.estimate,
number_iter = 8000,
thinning = 5,
empirical = TRUE,
burn_in = 5000,
quadratic = FALSE,
iter_update = 1000,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta)
beta_compare(Y = sim_data_markergene,
normHDP_post_output = MCMC_run1,
data.names = c('data1','data2'))
difference_in_component1 <- difference_in_p_jd2(p_jd_trace = MCMC_run1$P_J_D_output)
# Distribution of posterior estimated capture efficiency for each cluster
beta_analysis(normHDP_post_output = MCMC_run1,
cluster.labels = difference_in_component1$all_obs)
mu_and_phi_plot(normHDP_post_output = MCMC_run1,
row.n = 3)
gmg_df1 <- global_marker_genes(normHDP_post_output = MCMC_run1,
threshold = list('mu' = 2.5,
'phi' = 2.5),
num.cores = 4,
run.on.pc = TRUE)
global_marker_genes_plot(gmg_output = gmg_df1)
global_marker_genes_heatmap(gmg_output = gmg_df1,
normHDP_post_output = MCMC_run1)
global_marker_genes_heatmap(gmg_output = gmg_df1,
normHDP_post_output = MCMC_run1)
beta_analysis(normHDP_post_output = MCMC_run1,
cluster.labels = difference_in_component1$all_obs)
mu_and_phi_plot(normHDP_post_output = MCMC_run1,
row.n = 3)
gmg_df1 <- global_marker_genes(normHDP_post_output = MCMC_run1,
threshold = list('mu' = 2.5,
'phi' = 2.5),
num.cores = 4,
run.on.pc = TRUE)
global_marker_genes_plot(gmg_output = gmg_df1)
global_marker_genes_heatmap(gmg_output = gmg_df1,
normHDP_post_output = MCMC_run1)
MCMC_run1 <- normHDPcpp::normHDP_mcmc_fixed_z(Y = sim_data_markergene,
cluster_estimates = Z_opt1$cluster.estimate,
number_iter = 8000,
thinning = 5,
empirical = TRUE,
burn_in = 5000,
quadratic = FALSE,
iter_update = 1000,
beta_mean = 0.06,
alpha_mu_2 = -1,
adaptive_prop = 0.1,
num_cores = -1,
baynorm_mu_estimate = baynorm.mu.estimate,
baynorm_phi_estimate = baynorm.phi.estimate,
baynorm_beta = baynorm.beta)
lmg_df1 <- local_marker_genes(normHDP_post_output = MCMC_run1,
threshold = list('mu' = 0.8,
'phi' = 0.8),
num.cores = 4,
run.on.pc = TRUE)
local_marker_genes_plot(lmg_output = lmg_df1)
local_marker_genes_heatmap(lmg_output = lmg_df1,
normHDP_post_output = MCMC_run1)
gmg_df1 <- global_marker_genes(normHDP_post_output = MCMC_run1,
threshold = list('mu' = 2.5,
'phi' = 2.5),
num.cores = 4,
run.on.pc = TRUE)
global_marker_genes_plot(gmg_output = gmg_df1)
global_marker_genes_heatmap(gmg_output = gmg_df1,
normHDP_post_output = MCMC_run1)
local_marker_genes_plot(lmg_output = lmg_df1)
simulated_value <- list(
mu_star_1_J_output  = t(sim3_mu),       # (G × J) true gene means
phi_star_1_J_output = t(sim3_phi),      # (G × J) true dispersions
z_true   = sim3_Z,        # list of length D containing clusters for each dataset
G        = 150,
J        = 3,
D        = 2
)
gmg_df1 <- global_marker_genes(normHDP_post_output = simulated_value,
threshold = list('mu' = 2.5,
'phi' = 2.5),
num.cores = 4,
run.on.pc = TRUE)
simulated_value <- list(
mu_star_1_J_output  = sim3_mu,       # (G × J) true gene means
phi_star_1_J_output = sim3_phi,      # (G × J) true dispersions
z_true   = sim3_Z,        # list of length D containing clusters for each dataset
G        = 150,
J        = 3,
D        = 2
)
gmg_df1 <- global_marker_genes(normHDP_post_output = simulated_value,
threshold = list('mu' = 2.5,
'phi' = 2.5),
num.cores = 4,
run.on.pc = TRUE)
# t-SNE plot using all genes
tsne_plot(normHDP_post_output = MCMC_run1,
Y_latent = latent_counts_Y$Y_latent,
Y = sim_data_markergene)
latent_counts_Y <- latent_counts(Y = sim_data_markergene,
normHDP_post_output = MCMC_run1,
gmg_output = gmg_df1,
num.cores = 4,
run.on.pc = TRUE)
ppc_multiple_plot1 <- function(ppc_multiple_df,
title){
# Statistics
Y_statistics <- ppc_multiple_df$Y_statistics
rep_Y_statistics <- ppc_multiple_df$rep_Y_statistics
Y_statistics$source <- 'observed data'
rep_Y_statistics$source <- paste('replicated data', rep_Y_statistics$t)
# Dimension
D <- max(Y_statistics$dataset)
plot_list <- vector("list", D)
for(d in 1:D){
df_Y <- Y_statistics %>%
filter(dataset == d)
df_Y_rep <- rep_Y_statistics %>%
filter(dataset == d)
plot1 <- ggplot()+
geom_density(mapping = aes(x = mean.log.shifted.counts,
colour = source),
data = df_Y_rep,
size = 1.2)+
theme_bw()+
xlab('mean of log shifted counts')+
scale_color_manual(values=rep('grey',ppc_multiple_df$number_rep))+
theme(legend.position = "none")+
ggtitle(title[d])+
geom_density(mapping = aes(x = mean.log.shifted.counts,
colour = source),
data = df_Y,
size = 1.2,
colour = 'red')
plot2 <- ggplot()+
geom_density(mapping = aes(x = sd.log.shifted.counts,
colour = source),
data = df_Y_rep,
size = 1.2)+
theme_bw()+
xlab('standard deviaion of log shifted counts')+
scale_color_manual(values=rep('grey',ppc_multiple_df$number_rep))+
theme(legend.position = "none")+
ggtitle(title[d])+
geom_density(mapping = aes(x = sd.log.shifted.counts,
colour = source),
data = df_Y,
size = 1.2,
colour = 'red')
plot3 <- ggplot()+
geom_density(mapping = aes(x = dropout.probability,
colour = source),
data = df_Y_rep,
size = 1.2)+
theme_bw()+
xlab('dropout probabilities')+
scale_color_manual(values=rep('grey',ppc_multiple_df$number_rep))+
theme(legend.position = "none")+
ggtitle(title[d])+
geom_density(mapping = aes(x = dropout.probability,
colour = source),
data = df_Y,
size = 1.2,
colour = 'red')
print( ggarrange(plot1, plot2, plot3, nrow = 1) )
}
}
ppc_multiple_df <- ppc_multiple(normHDP_post_output = MCMC_run1,
Y = sim_data_markergene,
number_rep = 100,
num.cores = 4,
run.on.pc = TRUE)
true_marker_genes_heatmap <- function(sim_truth,
marker_output,
main_title = "True Marker Genes Heatmap") {
mu_mat <- sim_truth$mu_true        # G × J
marker_genes <- marker_output$marker_genes
if (length(marker_genes) == 0) {
stop("No marker genes detected. Try lowering the threshold.")
}
# subset only marker genes
mu_marker <- mu_mat[marker_genes, ]   # subset genes × J
# convert to long format for ggplot
df_long <- melt(mu_marker)
colnames(df_long) <- c("gene", "cluster", "mu")
# log-transform for visualization
df_long$log_mu <- log(df_long$mu + 1e-12)
# plot
ggplot(df_long, aes(x = gene, y = factor(cluster), fill = log_mu)) +
geom_tile() +
scale_fill_gradient2(low = "blue", high = "red", mid = "white", midpoint = median(df_long$log_mu),
name = "log(mu)") +
labs(
title = main_title,
x = "Marker Genes",
y = "Cluster"
) +
theme_bw() +
theme(
axis.text.x = element_blank(),
axis.ticks.x = element_blank(),
plot.title = element_text(size = 14, face = "bold"),
axis.title = element_text(size = 12)
)
}
get_true_marker_genes <- function(sim_truth, threshold = 1.0) {
mu_mat <- sim_truth$mu_true   # G × J
# compute log-fold-change range between clusters
log_mu <- log(mu_mat + 1e-12)   # avoid log(0)
# per gene, compute max difference between clusters
lfc_range <- apply(log_mu, 1, function(x) max(x) - min(x))
# marker if expression differs strongly across clusters
marker_genes <- which(lfc_range > threshold)
return(list(
marker_genes = marker_genes,
non_marker_genes = setdiff(1:sim_truth$G, marker_genes),
lfc_range = lfc_range
))
}
simulated_value <- list(
mu_true  = t(sim3_mu),
phi_true = t(sim3_phi),
z_true   = sim3_Z,
G        = GG,
J        = J,
D        = D,
C        = CC
)
true_marker_output <- get_true_marker_genes(simulated_value, threshold = 1.5)
# heatmap
true_marker_genes_heatmap(simulated_value, true_marker_output)
ppc_multiple_plot1(ppc_multiple_df = ppc_multiple_df,
title = c('data1', 'data2'))
library('bayNorm')
library(normHDPcpp)
library('normHDP')
library(tidyverse)
library(pbapply)
help("??normHDP")
set.seed(100)
#######   NormHDP with linear mu and phi   ###############
D = length(sim_data3)
setwd("Desktop/thesis/paper1/analysis/normhdpcpp_package/normHDPcpp")
Rcpp::compileAttributes()
devtools::document()
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
ls("package:normHDPcpp")
setwd("Desktop/thesis/paper1/analysis/normhdpcpp_package/normHDPcpp")
getwd()
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
ls("package:normHDPcpp")
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
ls("package:normHDPcpp")
Rcpp::compileAttributes()
devtools::document()
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
ls("package:normHDPcpp")
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
ls("package:normHDPcpp")
Rcpp::compileAttributes()
devtools::document()
devtools::load_all()
Rcpp::compileAttributes()
devtools::document()
Rcpp::compileAttributes()
devtools::document()
devtools::clean_dll() # Force R to forget the old C++ connection
devtools::load_all()  # Recompile everything from scratch
ls("package:normHDPcpp")
